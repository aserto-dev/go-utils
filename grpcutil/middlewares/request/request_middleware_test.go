package request

import (
	"context"
	"strings"
	"testing"

	"github.com/aserto-dev/go-utils/grpcutil"
	"github.com/aserto-dev/go-utils/grpcutil/middlewares/test"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

var (
	unaryInfo = &grpc.UnaryServerInfo{
		FullMethod: "TestService.UnaryMethod",
	}
	streamInfo = &grpc.StreamServerInfo{
		FullMethod:     "TestService.StreamMethod",
		IsServerStream: true,
	}
)

func TestUnaryServerWithoutRequestID(t *testing.T) {
	unaryHandler := func(ctx context.Context, req interface{}) (interface{}, error) {
		requestID := grpcutil.ExtractRequestID(ctx)
		if requestID == "" {
			t.Errorf("requestID must be generated by interceptor")
		}

		if got, want := grpcutil.ExtractRequestID(ctx), requestID; got != want {
			t.Errorf("expect requestID to %q, but got %q", want, got)
		}

		return "output", nil
	}

	ctx := grpc.NewContextWithServerTransportStream(context.Background(), test.ServerTransportStream(""))
	_, err := NewRequestIDMiddleware().Unary()(ctx, "xyz", unaryInfo, unaryHandler)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestUnaryServerWithRequestID(t *testing.T) {
	assert := require.New(t)
	requestID, err := uuid.NewUUID()
	assert.NoError(err)

	unaryHandler := func(ctx context.Context, req interface{}) (interface{}, error) {
		assert.True(strings.HasPrefix(grpcutil.ExtractRequestID(ctx), requestID.String()))
		return "output", nil
	}

	ctx := context.Background()
	md := metadata.Pairs(string(grpcutil.HeaderAsertoRequestID), requestID.String())
	ctx = grpc.NewContextWithServerTransportStream(ctx, test.ServerTransportStream(""))
	ctx = metadata.NewIncomingContext(ctx, md)

	_, err = NewRequestIDMiddleware().Unary()(ctx, "xyz", unaryInfo, unaryHandler)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestUnaryServerWithRequestIDChain(t *testing.T) {
	assert := require.New(t)
	requestID, err := uuid.NewUUID()
	assert.NoError(err)

	unaryHandler := func(ctx context.Context, req interface{}) (interface{}, error) {
		gotRequestID := grpcutil.ExtractRequestID(ctx)

		requestIDs := strings.Split(gotRequestID, ".")
		if got, want := len(requestIDs), 2; got != want {
			t.Errorf("expect the number of request id to %d, but got %d", want, got)
		}
		if got, want := requestIDs[0], requestID; got != want.String() {
			t.Errorf("expect first request id to %q, but got %q", want, got)
		}
		return "output", nil
	}

	ctx := context.Background()
	md := metadata.Pairs(string(grpcutil.HeaderAsertoRequestID), requestID.String())
	ctx = grpc.NewContextWithServerTransportStream(ctx, test.ServerTransportStream(""))
	ctx = metadata.NewIncomingContext(ctx, md)
	_, err = NewRequestIDMiddleware().Unary()(ctx, "xyz", unaryInfo, unaryHandler)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestUnaryServerWithValidator(t *testing.T) {
	assert := require.New(t)
	requestID := "xyz"

	unaryHandler := func(ctx context.Context, req interface{}) (interface{}, error) {
		if got, want := grpcutil.ExtractRequestID(ctx), requestID; got == want {
			t.Errorf("original request id should be invalid")
		}
		return "output", nil
	}

	ctx := context.Background()
	md := metadata.Pairs(string(grpcutil.HeaderAsertoRequestID), requestID)
	ctx = metadata.NewIncomingContext(ctx, md)
	ctx = grpc.NewContextWithServerTransportStream(ctx, test.ServerTransportStream(""))
	_, err := NewRequestIDMiddleware().Unary()(ctx, "xyz", unaryInfo, unaryHandler)

	assert.NoError(err)
}

func TestUnaryClient(t *testing.T) {
	assert := require.New(t)
	requestID, err := uuid.NewUUID()
	assert.NoError(err)

	unaryInvoker := func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, opts ...grpc.CallOption) error {
		id := OutgoingRequestID(ctx)
		assert.Equal(requestID.String(), id)

		return nil
	}

	ctx := grpcutil.ContextWithRequestID(context.Background(), requestID.String())

	err = NewRequestIDMiddleware().UnaryClient()(ctx, "method", "req", "rep", nil, unaryInvoker)
	assert.NoError(err)
}

func TestStreamClient(t *testing.T) {
	assert := require.New(t)
	requestID, err := uuid.NewUUID()
	assert.NoError(err)

	streamer := func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) {
		id := OutgoingRequestID(ctx)
		assert.Equal(requestID.String(), id)

		return nil, nil
	}

	ctx := grpcutil.ContextWithRequestID(context.Background(), requestID.String())

	_, err = NewRequestIDMiddleware().StreamClient()(ctx, nil, nil, "method", streamer)
	assert.NoError(err)
}

func TestStreamServerWithoutRequestID(t *testing.T) {
	streamHandler := func(srv interface{}, stream grpc.ServerStream) error {
		requestID := grpcutil.ExtractRequestID(stream.Context())
		if requestID == "" {
			t.Errorf("requestID must be generated by interceptor")
		}

		if got, want := grpcutil.ExtractRequestID(stream.Context()), requestID; got != want {
			t.Errorf("expect requestID to %q, but got %q", want, got)
		}
		return nil
	}
	testService := struct{}{}
	ctx := grpc.NewContextWithServerTransportStream(context.Background(), test.ServerTransportStream(""))
	testStream := test.ServerStream(ctx)

	err := NewRequestIDMiddleware().Stream()(testService, testStream, streamInfo, streamHandler)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestStreamServerWithRequestID(t *testing.T) {
	assert := require.New(t)
	requestID, err := uuid.NewUUID()
	assert.NoError(err)

	streamHandler := func(srv interface{}, stream grpc.ServerStream) error {
		requestID := grpcutil.ExtractRequestID(stream.Context())
		if requestID == "" {
			t.Errorf("requestID must be generated by interceptor")
		}

		if got, want := grpcutil.ExtractRequestID(stream.Context()), requestID; got != want {
			t.Errorf("expect requestID to %q, but got %q", want, got)
		}
		return nil
	}
	testService := struct{}{}
	ctx := context.Background()
	md := metadata.Pairs(string(grpcutil.HeaderAsertoRequestID), requestID.String())
	ctx = metadata.NewIncomingContext(ctx, md)
	ctx = grpc.NewContextWithServerTransportStream(ctx, test.ServerTransportStream(""))
	testStream := test.ServerStream(ctx)

	err = NewRequestIDMiddleware().Stream()(testService, testStream, streamInfo, streamHandler)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestStreamServerWithRequestIDChain(t *testing.T) {
	assert := require.New(t)
	requestID, err := uuid.NewUUID()
	assert.NoError(err)

	streamHandler := func(srv interface{}, stream grpc.ServerStream) error {
		gotRequestID := grpcutil.ExtractRequestID(stream.Context())

		requestIDs := strings.Split(gotRequestID, ".")
		if got, want := len(requestIDs), 2; got != want {
			t.Errorf("expect the number of request id to %d, but got %d", want, got)
		}
		if got, want := requestIDs[0], requestID; got != want.String() {
			t.Errorf("expect first request id to %q, but got %q", want, got)
		}
		return nil
	}
	testService := struct{}{}
	ctx := context.Background()
	md := metadata.Pairs(string(grpcutil.HeaderAsertoRequestID), requestID.String())
	ctx = metadata.NewIncomingContext(ctx, md)
	ctx = grpc.NewContextWithServerTransportStream(ctx, test.ServerTransportStream(""))
	testStream := test.ServerStream(ctx)

	err = NewRequestIDMiddleware().Stream()(testService, testStream, streamInfo, streamHandler)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestStreamServerWithValidator(t *testing.T) {
	assert := require.New(t)
	requestID := "xyz"

	streamHandler := func(srv interface{}, stream grpc.ServerStream) error {
		gotRequestID := grpcutil.ExtractRequestID(stream.Context())
		if gotRequestID == requestID {
			t.Errorf("original request id should be invalid")
		}
		return nil
	}
	testService := struct{}{}
	ctx := context.Background()
	md := metadata.Pairs(string(grpcutil.HeaderAsertoRequestID), requestID)
	ctx = metadata.NewIncomingContext(ctx, md)
	ctx = grpc.NewContextWithServerTransportStream(ctx, test.ServerTransportStream(""))
	testStream := test.ServerStream(ctx)

	err := NewRequestIDMiddleware().Stream()(testService, testStream, streamInfo, streamHandler)
	assert.NoError(err)
}
